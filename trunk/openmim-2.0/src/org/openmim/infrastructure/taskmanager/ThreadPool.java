/* Generated by VDGG */
/* With joe's wait(100) fix */

package org.openmim.infrastructure.taskmanager;

import java.util.*;

import org.apache.log4j.Logger;
import org.apache.log4j.Level;

/**
 * @author VDGG
 * @version 1.0
 */
public class ThreadPool {
    private static final Logger CAT = Logger.getLogger(ThreadPool.class);
    private static final Thread[] thrArrType = new Thread[0];

    private static long cnt = 0;

    private static long threadGroupCnt = 0;
    private static final Object threadGroupSync = new Object();

    private static long getNextThreadGroupNumber() {
        synchronized (threadGroupSync) {
            return threadGroupCnt++;
        }
    }

    private final Stack<WorkerThread> pool;
    private final Stack<WorkerThread> tempPool;
    private int optWorkers;
    private int tempPoolDepth;
    private int additionalCount = 0;
    private ThreadGroup group;

    private final List<WorkerThread> aliveThreads = new ArrayList<WorkerThread>();

    private final Object stopSync = new Object();
    private boolean stopped = false;

    public ThreadPool(int maxWorkers, int optWorkers) {
        this.optWorkers = optWorkers;
        group = new ThreadGroup("ThreadPoolThreadGroup" + getNextThreadGroupNumber());
        pool = new Stack<WorkerThread>();
        tempPoolDepth = maxWorkers > optWorkers ? maxWorkers - optWorkers : -1;
        tempPool = new Stack<WorkerThread>();
        for (int i = 0; i < optWorkers; i++) {
            synchronized (stopSync) {
                if (!stopped) {
                    WorkerThread w = new WorkerThread(this, "WorkerThread" + (cnt++), group);
                    pool.push(w);
                }
            }
        }
    }

    public void execute(Task task) {
        if (stopped)
            return;
        WorkerThread workerThread = null;
        while (workerThread == null) {
            try {
                workerThread = pool.pop();
            } catch (EmptyStackException ex) {
                //eat
            }
            if (workerThread == null) {
                try {
                    workerThread = tempPool.pop();
                } catch (EmptyStackException ex) {
                    //eat
                }
                if (workerThread == null) {
                    if (additionalCount >= tempPoolDepth) {
                        try {
                            synchronized (this) {
                                wait(100);
                            }
                        } catch (InterruptedException ex) {
                            CAT.error("InterruptedException during wait", ex);
                        }
                    } else {
                        synchronized (stopSync) {
                            if (!stopped) {
                                workerThread = new WorkerThread(this, "WorkerThread" + (cnt++), group);
                                additionalCount++;
                            }
                        }
                    }
                }
            }
        }
        try {
            workerThread.setActiveTask(task);
        } catch (Exception ex) {
            CAT.error("Exception ", ex);
        }
    }

    public void pushWorker(WorkerThread workerThread) {
        pool.push(workerThread);
    }

    public void pushTempWorker(WorkerThread workerThread) {
        tempPool.push(workerThread);
    }

    public void releaseTempWorker(WorkerThread workerThread) {
        synchronized (tempPool) {
            tempPool.remove(workerThread);
        }
    }

    public void addAliveWorker(WorkerThread workerThread) {
        synchronized (aliveThreads) {
            aliveThreads.add(workerThread);
        }
    }

    public void releaseAliveWorker(WorkerThread workerThread) {
        synchronized (aliveThreads) {
            aliveThreads.remove(workerThread);
        }
    }

    public void stop(int timeout) {
        CAT.debug("Stopping ThreadPool");
        synchronized (stopSync) {
            stopped = true;
            Thread[] threadList = aliveThreads.toArray(thrArrType);
            for (Thread thread : threadList) {
                if (thread != null && thread.isAlive()) {
                    thread.interrupt();
                    try {
                        thread.join(timeout);
                        if (CAT.isEnabledFor(Level.INFO))
                            CAT.info("Thread " + thread + " stopped ok");
                    } catch (InterruptedException e) {
                        CAT.error("InterruptedException in stop during join", e);
                    }
                    if (thread.isAlive()) {
                        //noinspection deprecation
                        thread.stop();
                        if (CAT.isEnabledFor(Level.WARN))
                            CAT.warn("Thread " + thread + " emergency stop");
                    }
                }
            }
        }
    }

    public void joinOptThreads() throws InterruptedException {
        boolean interrupted = false;
        while ((pool.size() < optWorkers) && !(interrupted = Thread.interrupted()))
            Thread.yield();
        if (interrupted)
            throw new InterruptedException("Thread is interrupted in join");
    }
}
