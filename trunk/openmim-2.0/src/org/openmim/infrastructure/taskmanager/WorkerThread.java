/* Generated by VDGG */

package org.openmim.infrastructure.taskmanager;

import org.apache.log4j.Logger;
import org.apache.log4j.Level;

/**
 * @author VDGG
 * @version 1.0
 */
class WorkerThread extends Thread {
    private static final Logger CAT = Logger.getLogger(WorkerThread.class);

    final static int READY = 0;
    final static int BUSY = 1;

    private int state;
    private Task activeTask;
    private ThreadPool manager;
    private boolean liveForever;
    private long timeout;

    WorkerThread(ThreadPool manager, String name, ThreadGroup group) {
        super(group, name);
        this.manager = manager;
        setWorkerState(READY);
        liveForever = true;
    }

    WorkerThread(ThreadPool manager, long timeout, String name, ThreadGroup group) {
        this(manager, name, group);
        liveForever = false;
        this.timeout = timeout;
    }

    public synchronized void run() {
        manager.addAliveWorker(this);
        try {
            while (getWorkerState() == BUSY && !isInterrupted()) {
                if (activeTask != null) {
                    try {
                        activeTask.execute();
                    } catch (InterruptedException ex) {
                        if (CAT.isEnabledFor(Level.DEBUG))
                            CAT.debug("Thread " + this + " interrupted ok");
                        return;
                    } catch (Exception ex) {
                        ex.printStackTrace();
                        if (CAT.isEnabledFor(Level.ERROR))
                            CAT.error("Exception thrown by thread " + this, ex);
                    } finally {
                        activeTask = null;
                        setWorkerState(READY);
                        if (liveForever)
                            manager.pushWorker(this);
                        else
                            manager.pushTempWorker(this);
                        synchronized (manager) {
                            manager.notify();
                        }
                    }
                }
                try {
                    if (liveForever)
                        wait();
                    else
                        wait(timeout);
                } catch (InterruptedException iex) {
                    if (CAT.isEnabledFor(Level.DEBUG))
                        CAT.debug("Thread " + this + " interrupted ok");
                    return;
                }
            }
        } finally {
            manager.releaseTempWorker(this);
            manager.releaseAliveWorker(this);
        }
    }

    public synchronized void setActiveTask(Task task) throws IllegalStateException {
        setWorkerState(BUSY);
        activeTask = task;
        if (isAlive())
            notify();
        else
            start();
    }

    public int getWorkerState() {
        return state;
    }

    private void setWorkerState(int state) {
        this.state = state;
    }
}

